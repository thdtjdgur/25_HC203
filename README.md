# ğŸ’¡1. í”„ë¡œì íŠ¸ ê°œìš”
## 1-1. í”„ë¡œì íŠ¸ ì†Œê°œ
- í”„ë¡œì íŠ¸ ëª…: ë©”ë””ì›¨ì´(MediWay) - ì—…ë¬´ ë³´ì¡° ë° ë³‘ì› ë‚´ ê¸¸ì•ˆë‚´ ë¡œë´‡
- í”„ë¡œì íŠ¸ ì •ì˜: ì˜ì•½í’ˆ ë°°ë‹¬Â·í˜¸ì¶œ ì‹œ ìœ„ì¹˜ ì´ë™Â·ë‚´ë¹„ ì œê³µ ë¡œë´‡ì„ ê°œë°œí•´ ìŠ¤ë§ˆíŠ¸ ë³‘ì› êµ¬ì¶•ì„ ìœ„í•œ ë¡œë´‡

## 1-2. ê°œë°œ ë°°ê²½ ë° í•„ìš”ì„±
- í˜„ì¬ ë³‘ì›ì—ì„œëŠ” ì˜ë£Œì§„ê³¼ ì§ì›ë“¤ì´ ì§ì ‘ ì˜ì•½í’ˆì„ ìš´ë°˜í•˜ê±°ë‚˜, í™˜ìê°€ ë³‘ì› ë‚´ë¶€ì—ì„œ ê¸¸ì„ ì°¾ëŠ” ë° ì–´ë ¤ì›€ì„
  ê²ªëŠ” ê²½ìš°ê°€ ë§ë‹¤. ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì‹¤ë‚´ ê¸¸ì°¾ê¸° ì–´í”Œì´ë‚˜ ê¸¸ì•ˆë‚´ ë¡œë´‡ì´ ìˆëŠë‚˜, ê°ê° ì ‘ê·¼ì„±ì´
  ì–´ë µë‹¤ëŠ” ì ê³¼ ê¸°ëŠ¥ì´ í•˜ë‚˜ë¡œ ì œí•œëœë‹¤ëŠ” ì ì„ ê°œì„ í•˜ê¸° ìœ„í•´ ë³¸ í”„ë¡œì íŠ¸ë¥¼ êµ¬ìƒí•˜ì˜€ë‹¤.

## 1-3. í”„ë¡œì íŠ¸ íŠ¹ì¥ì 
- AI í•„í„°ë§(ì¹¼ë§ŒÂ·PF)ê³¼ ë‹¤ì¤‘ BLE ë¹„ì½˜ ì‚¼ê°ì¸¡ëŸ‰ìœ¼ë¡œ ì‹¤ì‹œê°„ ìœ„ì¹˜ ì˜¤ì°¨ Â±30 cm ë‹¬ì„±
- í˜¸ì¶œ ì‹œ ì‚¬ìš©ì ìœ„ì¹˜ë¡œ ì´ë™í•´ ë‚´ë¹„ê²Œì´ì…˜/ì•ˆë‚´ ì œê³µ(ë§¥ë½ ê¸°ë°˜ ë™ì„  ìµœì í™”)
- ROS ê¸°ë°˜ ê²½ë¡œ ìµœì í™”Â·PID ì œì–´Â·LiDAR ì¥ì• ë¬¼ íšŒí”¼ë¡œ ë³‘ì› ë‚´ ì™„ì „ ììœ¨ ì£¼í–‰
- ì„œë³´ëª¨í„°ë¥¼ í†µí•œ ë§ì¶¤ ì˜ì•½í’ˆ ì„ ë³„Â·ì ì¬Â·ë°°ë‹¬ë¡œ ìˆ˜ì‘ì—… ëŒ€ì²´

## 1-4. ì£¼ìš”ê¸°ëŠ¥
- ì‹¤ì‹œê°„ ìœ„ì¹˜ì¶”ì  : BLE í•‘ê±°í”„ë¦°íŒ…ê³¼ IMU(ì¹¼ë§ŒÂ·EKF) ìœµí•©ìœ¼ë¡œ ì •ë°€ ìœ„ì¹˜ ì‚°ì¶œ, ê²½ë¡œ ì‹œê°í™”
- ììœ¨ ì£¼í–‰ ë‚´ë¹„ê²Œì´ì…˜ : AMCLë¡œ ìœ„ì¹˜ íŒŒì•…, A* ê²½ë¡œ ìƒì„±, LiDAR ê¸°ë°˜ ì´ë™ ì¥ì• ë¬¼ íšŒí”¼
- ìë™ ì˜ì•½í’ˆ ë°°ë‹¬ : í˜¸ì¶œ ì‹œ ì‚¬ìš©ì ìœ„ì¹˜ë¡œ ì´ë™, ë¯¸í˜¸ì¶œ ì‹œ ì§€ì • êµ¬ê°„ ì™•ë³µ ìš´í–‰
- ì‚¬ìš©ì ì•ˆë‚´ ë””ìŠ¤í”Œë ˆì´ : ì§ê´€ UIë¡œ ì‹¤ì‹œê°„ ìœ„ì¹˜Â·ë°©í–¥Â·ì´ë™ ê²½ë¡œ ì œê³µ
- ì„¼ì„œ ìœµí•© ì£¼í–‰ ì•ˆì •í™” : LiDARÂ·myAHRS+Â·ì—”ì½”ë” í†µí•©ìœ¼ë¡œ ì£¼í–‰ ì‹ ë¢°ì„± í–¥ìƒ
- í•˜ë“œì›¨ì–´ ì—…ê·¸ë ˆì´ë“œ : ê³ ê¸°ì–´ë¹„ DC ëª¨í„° ì ìš©ìœ¼ë¡œ ì£¼í–‰ ì„±ëŠ¥ ê°œì„ 

## 1-5. ê¸°ëŒ€ íš¨ê³¼ ë° í™œìš© ë¶„ì•¼
- ê¸°ëŒ€ íš¨ê³¼ : ì˜ë£Œì§„ ë°˜ë³µ ìš´ë°˜ ì—…ë¬´ ìë™í™”ë¡œ ì´ë™ ì‹œê°„ ì ˆê°(í•˜ë£¨ ìµœëŒ€ 2ì‹œê°„, ì—°ê°„ ì•½ 500ì‹œê°„),
  ì¦‰ì‹œ ê¸¸ì•ˆë‚´Â·ì‹ ì† ì „ë‹¬ë¡œ í™˜ìÂ·ì˜ë£Œì§„ ë§Œì¡±ë„ í–¥ìƒ, ì„œë³´ëª¨í„° ê¸°ë°˜ ì„ ë³„ë¡œ ì˜¤ë°°ì†¡Â·ì§€ì—° ì˜¤ë¥˜ ê°ì†Œ
- í™œìš© ë¶„ì•¼ : ë³‘ë™ ë‚´ ì˜ì•½í’ˆÂ·ê²€ì²´Â·ì‹ìì¬ ì •ê¸°/ê¸´ê¸‰ ë°°ë‹¬, í™˜ìÂ·ë°©ë¬¸ê° ì‹¤ë‚´ ê¸¸ì•ˆë‚´, ì›ë‚´ ìˆœì°°Â·ì†Œëª¨í’ˆ
  ì ê²€ ë³´ì¡°, êµìœ¡Â·ë°ëª¨(ìˆ˜ì—…Â·ì „ì‹œ) í”Œë«í¼, ìš”ì–‘ì›Â·ì¬í™œì„¼í„° ë“± ì˜ë£ŒÂ·ë³µì§€ ì‹œì„¤ë¡œì˜ ë°°ë‹¬Â·ì•ˆë‚´ ì„œë¹„ìŠ¤ í™•ì¥

## 1-6. ê¸°ìˆ  ìŠ¤íƒ
- ë¡œë´‡/ë¯¸ë“¤ì›¨ì–´ : ROS Noetic (Catkin, ROS msg pub/sub, Service, Action), RViz
- ìš´ì˜ì²´ì œ : Ubuntu 20.04 LTS, Raspberry Pi OS
- ê°œë°œí™˜ê²½/IDE : Visual Studio Code, Git
- ê°œë°œì–¸ì–´ : C++, Python
- ì„¼ì„œ ë“œë¼ì´ë²„Â·í”„ë¡œí† ì½œ : LiDAR/IMU ROS ë“œë¼ì´ë²„, EKF/ì¹¼ë§Œ í•„í„° íŒŒì´í”„ë¼ì¸
- í•˜ë“œì›¨ì–´(ë””ë°”ì´ìŠ¤) : NVIDIA Jetson Nano, Raspberry Pi 4B, Arduino Mega, RA35GM(DC Motor)
- ì„¼ì„œ : YDLIDAR, myAHRS+, Minew BLE Indoor Beacon
- í†µì‹  : Wi-Fi (UDP), BLE
- í”„ë¡œì íŠ¸ ê´€ë¦¬Â·í˜‘ì—… : Git, KakaoTalk, Zoom, Slack
- ê¸°íƒ€ : êµ¬ë™ íœ  ì§€ë¦„ 10 cm


# ğŸ’¡2. íŒ€ì›ì†Œê°œ
![ê°œë°œì ì†Œê°œ](https://github.com/thdtjdgur/25_HC203/blob/main/%EC%97%AD%ED%95%A0%EB%B6%84%EB%8B%B4.png)


# ğŸ’¡3. ì‹œìŠ¤í…œ êµ¬ì„±ë„
## 3.1. í•˜ë“œì›¨ì–´ ì„¤ê³„ë„

<img src="https://github.com/thdtjdgur/25_HC203/blob/main/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84%EB%8F%84.png" width="500"/>



## 3.2. ì£¼í–‰ ì„œë¹„ìŠ¤ íë¦„ë„

<img src="https://github.com/thdtjdgur/25_HC203/blob/main/%EC%A3%BC%ED%96%89%20%EC%84%9C%EB%B9%84%EC%8A%A4%20%ED%9D%90%EB%A6%84%EB%8F%84.png" width="500"/>

1. Arduino megaì™€ rosì‹œë¦¬ì–¼í†µì‹ ì„ í†µí•´ ì—”ì½”ë”ê°’ì„ ì „ë‹¬ë°›ëŠ”ë‹¤.
2. ì—”ì½”ë”, imu(myahrs+), ydlidarì„¼ì„œ ìœµí•©ì„ í†µí•´ ë¡œë´‡ì˜ ìœ„ì¹˜ë¥¼ ê°±ì‹ í•œë‹¤.
3. ê¸°ì¡´ ë³‘ì›ì˜ ì§€ë„ë¥¼ ë¶ˆëŸ¬ì™€ ë¼ì´ë‹¤ì˜ ì„¼ì„œê°’ì„ í†µí•´ amclì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë¡œë´‡ì˜ ìœ„ì¹˜ë¥¼ íŒŒì•…í•œë‹¤.
4. ë¼ì¦ˆë² ë¦¬íŒŒì´ë¡œë¶€í„° ìƒí™©ì— ë”°ë¼ ì‚¬ìš©ììœ„ì¹˜, ì§„ë£Œì‹¤ìœ„ì¹˜, ì•½í’ˆë°°ë‹¬ìœ„ì¹˜ ì¢Œí‘œë¥¼ ì „ë‹¬ë°›ê³  ëª©í‘œìœ„ì¹˜ë¥¼ íŒŒì•… í•œ í›„  moe_baseë¡œ ì „ë‹¬í•œë‹¤.
5. ëª©í‘œìœ„ì¹˜ì™€ í˜„ì¬ ë¡œë´‡ì˜ ìœ„ì¹˜ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë³‘ì›ì—ì„œì˜ ë¡œë´‡ì˜ ìœ„ì¹˜ë¥¼ íŒŒì•…í•œë‹¤.
6. ë¼ì´ë‹¤ë¥¼ í†µí•´ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¥ì• ë¬¼ íšŒí”¼ê²½ë¡œë¥¼ ìƒì„±í•œë‹¤.
7. ìƒì„±ëœ geometry_msgs/Twist ë°ì´í„°ë¥¼ ëª¨í„°ì— ì „ë‹¬í•˜ì—¬ ì£¼í–‰í•œë‹¤.



## 3.3. ë””ìŠ¤í”Œë ˆì´ ì„œë¹„ìŠ¤ íë¦„ë„

<img src="https://github.com/thdtjdgur/25_HC203/blob/main/%EB%94%94%EC%8A%A4%ED%94%8C%EB%A0%88%EC%9D%B4%20%EC%84%9C%EB%B9%84%EC%8A%A4%20%ED%9D%90%EB%A6%84%EB%8F%84.png" width="500"/>

1. BLE beaconì„ í†µí•´ ë¯¸ë¦¬ ë³‘ì› ì „ì²´ì˜ ì‹ í˜¸ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì €ì¥í•˜ì—¬ í•‘ê±°í”„ë¦°íŒ… ë§µì„ ë§Œë“ ë‹¤.
2. ì‹¤ì‹œê°„ìœ¼ë¡œ ìœ„ì¹˜ì¶”ì  ì‹œ ë¹„ì½˜ì—ê²Œì„œ RSSI ì‹ í˜¸ë¥¼ ë°›ê³ , í•‘ê±°í”„ë¦°íŒ… ê¸°ë²•ì„ í†µí•´ í˜„ì¬ ìœ„ì¹˜ ì˜ˆì¸¡í•œë‹¤.
3. IMUì„¼ì„œì˜ PDRê¸°ë²•ì„ í†µí•´ ê±¸ìŒ ìˆ˜ì™€ ë°©í–¥ì„ ê²€ì¶œí•œë‹¤.
4. IMUì„¼ì„œì˜ ë°ì´í„°ì™€ ë¹„ì½˜ì˜ ë°ì´í„°ë¥¼ ë°›ì•„ EKFë¥¼ í†µí•´ ìœµí•©í•œë‹¤.
5. EKFì˜ ìœ„ì¹˜ ì •ë³´ì™€ IMUì˜ ë°©í–¥ì •ë³´ë¥¼ ì§€ë„ì— í‘œì‹œí•œë‹¤.

# ğŸ’¡5. í•µì‹¬ ì†ŒìŠ¤ì½”ë“œ
- ë¼ì¦ˆë² ë¦¬íŒŒì´ì™€ ROS ë…¸ë“œ ê°„ UDP í†µì‹ ì„ í†µí•´ ì¢Œí‘œ, ì‹ í˜¸ë¥¼ ì£¼ê³ ë°›ìœ¼ë©° ë¡œë´‡ì„ ì œì–´í•œë‹¤.
- ì˜¤ë„ë©”íŠ¸ë¦¬ì™€ ë¼ì´ë‹¤/IMU ë°ì´í„°ë¥¼ TF ë³€í™˜í•´ ë¡œë´‡ì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì¶”ì í•œë‹¤.
- ìƒíƒœë¨¸ì‹ (ì‚¬ìš©ì í˜¸ì¶œ, ì§„ë£Œì‹¤ ì´ë™, ì•½í’ˆ ë°°ë‹¬ ë“±)ì— ë”°ë¼ ëª©í‘œ ì¢Œí‘œë¥¼ ì„¤ì •í•˜ê³  ë„¤ë¹„ê²Œì´ì…˜ì„ ìˆ˜í–‰í•œë‹¤.
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
mediway1 ë…¸ë“œ
ë¼ì¦ˆë² ë¦¬íŒŒì´ í”½ì…€(u,v) â†’ ë¯¸í„°(X,Y)
RViz Marker / /move_base_simple/goal /clicked_position
"""

import socket
import rospy
from geometry_msgs.msg import Point, PoseStamped, Pose, Quaternion
from visualization_msgs.msg import Marker
from nav_msgs.msg import Odometry
from std_msgs.msg import Int32, Header

import math
import tf2_ros
import tf2_geometry_msgs

# â”€â”€â”€â”€â”€â”€â”€â”€â”€ íŒŒë¼ë¯¸í„° & ìƒìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€
PIX_W, PIX_H = 762.0, 574.0
lu_x, lu_y = 1.0, -1.8
ld_x, ld_y = 3.7, -0.3
ru_x, ru_y = -1.0, 1.7
rd_x, rd_y = 1.5, 3.2

RPI_IP = "10.24.184.1"     # â† ì‹¤ì œ IP
RPI_PORT = 5005            # â† RPi ìˆ˜ì‹  í¬íŠ¸(ì¢Œí‘œ/ì‹ í˜¸)
RPI_PORT_SIGNAL = 5006     # â† 999,999 ë“± ì‹ í˜¸ ë¶„ë¦¬ìš©(ì›ì¹˜ ì•Šìœ¼ë©´ RPI_PORTì™€ ë™ì¼í•˜ê²Œ ì¨ë„ ë¨)

GOAL_THRESH = 0.35

# ì•½í’ˆ ìœ„ì¹˜(ì‹¤ì¢Œí‘œë¡œ êµì²´ ê°€ëŠ¥)
MED1_GOAL = (1.1, -1.1)
MED2_GOAL = (3.0, -0.1)

# ìƒíƒœ ì •ì˜
STATE_IDLE          = "IDLE"
STATE_TO_USER       = "TO_USER"        # ì‚¬ìš©ìì—ê²Œ ì´ë™ ì¤‘
STATE_AT_USER       = "AT_USER"        # ì‚¬ìš©ì ë„ì°©(ì§„ë£Œì‹¤ ì¢Œí‘œ ëŒ€ê¸°)
STATE_TO_CLINIC     = "TO_CLINIC"      # ì§„ë£Œì‹¤ ì´ë™ ì¤‘ (RPiê°€ ì¢Œí‘œ ë³´ëƒ„)
STATE_TO_MED1       = "TO_MED1"        # ì•½1 ì´ë™ ì¤‘ (RPi ì¢Œí‘œ ì—†ìŒ)
STATE_TO_MED2       = "TO_MED2"        # ì•½2 ì´ë™ ì¤‘ (RPi ì¢Œí‘œ ì—†ìŒ)
STATE_WAIT_INPUT    = "WAITING_FOR_INPUT"
STATE_DELIVERING    = "DELIVERING"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì „ì—­ ë³€ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€
robot_x, robot_y = 0.0, 0.0
goal_x, goal_y   = 0.0, 0.0
state = STATE_IDLE

# ì‚¬ìš©ì ë„ì°© ì‹ í˜¸ 1íšŒ ì†¡ì‹ ìš©
user_signal_sent = False

# ì•½í’ˆ ë°°ë‹¬ ë‹¨ê³„(í˜„ì¬ íƒ€ê¹ƒ): Trueë©´ ì•½1, Falseë©´ ì•½2
medicine_target_is_med1 = True

# ì•½í’ˆ íˆ¬ì… ì¤‘ ë“¤ì–´ì˜¨ ì‚¬ìš©ì í˜¸ì¶œ ë³´ë¥˜ ìš©
pending_user_call = False
pending_u = None
pending_v = None

# ì†Œì¼“
pos_sock = None  # ë¡œë´‡ ì¢Œí‘œ TX
tx_sock  = None  # ì‹ í˜¸ TX

# TF
_tf_buffer = None
_tf_listener = None


def pixel_to_meter(u: float, v: float):
    s = u / PIX_W
    t = v / PIX_H
    X = ((1-s)*(1-t)*lu_x + s*(1-t)*ru_x + (1-s)*t*ld_x + s*t*rd_x)
    Y = ((1-s)*(1-t)*lu_y + s*(1-t)*ru_y + (1-s)*t*ld_y + s*t*rd_y)
    return X, Y


def send_pose_timer_cb(event):
    """0.5ì´ˆë§ˆë‹¤ ë¡œë´‡ ì¢Œí‘œë¥¼ RPië¡œ ì „ì†¡ (í•­ìƒ ì†¡ì‹ : RPiê°€ í•„ìš”í•  ë•Œë§Œ ì‚¬ìš©)"""
    global robot_x, robot_y, pos_sock
    if pos_sock is None:
        return
    try:
        msg = f"{robot_x:.3f},{robot_y:.3f}".encode()
        pos_sock.sendto(msg, (RPI_IP, RPI_PORT))
    except Exception as e:
        rospy.logwarn(f"[POSE_TX] UDP send failed: {e}")


def odom_callback(msg: Odometry):
    """odomâ†’map ìµœì‹  ì‹œê° ë³€í™˜ (extrapolation ë°©ì§€), ì½œë°± ë‚´ sleep ê¸ˆì§€"""
    global robot_x, robot_y, _tf_buffer
    odom_pose = msg.pose.pose
    try:
        transform = _tf_buffer.lookup_transform(
            "map",
            msg.header.frame_id,   # ë³´í†µ "odom"
            rospy.Time(0),         # ìµœì‹ 
            rospy.Duration(0.2)
        )
    except Exception as ex:
        rospy.logwarn(f"Transform failed: {ex}")
        return

    map_pose_st = tf2_geometry_msgs.do_transform_pose(
        PoseStamped(header=msg.header, pose=odom_pose),
        transform
    )
    robot_x = map_pose_st.pose.position.x
    robot_y = map_pose_st.pose.position.y


def distance_to_goal() -> float:
    return math.hypot(robot_x - goal_x, robot_y - goal_y)


def set_goal(x, y):
    global goal_x, goal_y
    goal_x, goal_y = x, y


def udp_listener():
    global _tf_buffer, _tf_listener
    global pos_sock, tx_sock
    global state, goal_x, goal_y
    global user_signal_sent
    global medicine_target_is_med1
    global pending_user_call, pending_u, pending_v

    rospy.init_node("mediway1")

    point_pub  = rospy.Publisher("/clicked_position", Point, queue_size=10)
    goal_pub   = rospy.Publisher("/move_base_simple/goal", PoseStamped, queue_size=10)
    marker_pub = rospy.Publisher("/goal_marker", Marker, queue_size=10)
    servo_pub  = rospy.Publisher("/servo_control", Int32, queue_size=10)

    # TF
    _tf_buffer = tf2_ros.Buffer()
    _tf_listener = tf2_ros.TransformListener(_tf_buffer)
    rospy.Subscriber("/odom", Odometry, odom_callback, queue_size=1)

    # UDP
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("0.0.0.0", 5005))
    sock.settimeout(2)  # 2ì´ˆ ì•ˆì— ì˜¤ë©´ got_udp=True (ì „ì œ ìœ ì§€)

    tx_sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    pos_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    rospy.Timer(rospy.Duration(0.5), send_pose_timer_cb)  # 0.5ì´ˆ ì£¼ê¸° ì¢Œí‘œ TX

    rospy.loginfo("UDP 5005 listening (mediway1)")
    rate = rospy.Rate(50)

    # ì´ˆê¸° ìƒíƒœ: ì•½1ë¶€í„° ì‹œì‘
    set_goal(*MED1_GOAL)
    state = STATE_TO_MED1
    rospy.loginfo("ì•½í’ˆ1 ë°°ë‹¬ ì§€ì ìœ¼ë¡œ ì´ë™ì¤‘(ì´ˆê¸°)")

    while not rospy.is_shutdown():
        # 1) RPi ì¢Œí‘œ ìˆ˜ì‹ 
        got_udp = False
        u = v = None
        try:
            data, _ = sock.recvfrom(1024)
            u_str, v_str = data.decode().strip().split(",")
            u, v = float(u_str), float(v_str)
            got_udp = True
        except socket.timeout:
            pass
        except (ValueError, IndexError):
            rospy.logwarn("ì˜ëª»ëœ UDP ë°ì´í„° í˜•ì‹ ìˆ˜ì‹ ")

        # 1.5) ì•½í’ˆ ì´ë™ ì¤‘ ì‚¬ìš©ì í˜¸ì¶œ ì¦‰ì‹œ ì „í™˜
        if got_udp and state in [STATE_TO_MED1, STATE_TO_MED2]:
            set_goal(*pixel_to_meter(u, v))
            state = STATE_TO_USER
            user_signal_sent = False
            pending_user_call = False
            rospy.loginfo("ì‚¬ìš©ì í˜¸ì¶œ ìˆ˜ì‹  â†’ ì‚¬ìš©ìì—ê²Œë¡œ ì¦‰ì‹œ ì „í™˜")

        # 1.6) ì•½í’ˆ íˆ¬ì… ëŒ€ê¸°/ë°°ì¶œ ì¤‘ í˜¸ì¶œì€ ë³´ë¥˜
        if got_udp and state in [STATE_WAIT_INPUT, STATE_DELIVERING]:
            pending_user_call = True
            pending_u, pending_v = u, v
            rospy.loginfo("ì‚¬ìš©ì í˜¸ì¶œ ìˆ˜ì‹ (ì•½í’ˆ íˆ¬ì… ì¤‘) â†’ ì¢…ë£Œ í›„ ì‚¬ìš©ìë¡œ ì „í™˜ ì˜ˆì•½")

        # 2) ìƒíƒœ ë¨¸ì‹  ë³¸ ì²˜ë¦¬
        if state == STATE_TO_MED1:
            if distance_to_goal() < GOAL_THRESH:
                rospy.loginfo("ì•½í’ˆ1 ë°°ë‹¬ ì§€ì  ë„ì°©!")
                state = STATE_WAIT_INPUT
                # ì •ì§€
                goal_pub.publish(PoseStamped(
                    header=Header(stamp=rospy.Time.now(), frame_id="map"),
                    pose=Pose(position=Point(robot_x, robot_y, 0), orientation=Quaternion(0,0,0,1))
                ))
            else:
                rospy.loginfo("ì•½í’ˆ1 ë°°ë‹¬ ì§€ì ìœ¼ë¡œ ì´ë™ì¤‘")

        elif state == STATE_TO_MED2:
            if distance_to_goal() < GOAL_THRESH:
                rospy.loginfo("ì•½í’ˆ2 ë°°ë‹¬ ì§€ì  ë„ì°©!")
                state = STATE_WAIT_INPUT
                goal_pub.publish(PoseStamped(
                    header=Header(stamp=rospy.Time.now(), frame_id="map"),
                    pose=Pose(position=Point(robot_x, robot_y, 0), orientation=Quaternion(0,0,0,1))
                ))
            else:
                rospy.loginfo("ì•½í’ˆ2 ë°°ë‹¬ ì§€ì ìœ¼ë¡œ ì´ë™ì¤‘")

        elif state == STATE_WAIT_INPUT:
            # ë¸”ë¡œí‚¹ ì…ë ¥(í˜„ì¥ì—ì„  ì„œë¹„ìŠ¤/ì•¡ì…˜ ê¶Œì¥)
            try:
                user_input = input("ì•½í’ˆ ë°°ë‹¬ ì§€ì  ë„ì°©. ì•½í’ˆ ë²ˆí˜¸(1-4)ë¥¼ ì…ë ¥í•˜ê³  Enter: ")
                servo_num = int(user_input)
                if 1 <= servo_num <= 4:
                    rospy.loginfo(f"{servo_num}ë²ˆ ì•½í’ˆ ë°°ì¶œ ì‹œì‘.")
                    servo_pub.publish(servo_num)
                    state = STATE_DELIVERING
                else:
                    print("ì˜ëª»ëœ ë²ˆí˜¸ì…ë‹ˆë‹¤. 1~4 ì‚¬ì´ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
            except ValueError:
                print("ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")

        elif state == STATE_DELIVERING:
            rospy.loginfo("ì•½í’ˆ ë°°ì¶œ ì¤‘... (ì•½ 6ì´ˆê°„ ëŒ€ê¸°)")
            rospy.sleep(3.0)
            rospy.loginfo("ì•½í’ˆ ë°°ì¶œ ì™„ë£Œ.")

            # ë°°ì¶œ ì¤‘ í˜¸ì¶œì´ ë“¤ì–´ì™”ë‹¤ë©´ ìµœìš°ì„  ì „í™˜
            if pending_user_call:
                set_goal(*pixel_to_meter(pending_u, pending_v))
                state = STATE_TO_USER
                user_signal_sent = False
                pending_user_call = False
                rospy.loginfo("ë°°ì¶œ ì™„ë£Œ â†’ ì˜ˆì•½ëœ ì‚¬ìš©ì í˜¸ì¶œë¡œ ì „í™˜")
            else:
                # ë‹¤ìŒ ì•½í’ˆ ì§€ì ìœ¼ë¡œ ì¦‰ì‹œ ì´ë™ ì‹œì‘
                if medicine_target_is_med1:
                    # ë°©ê¸ˆ ì•½1 ì²˜ë¦¬ â†’ ì•½2ë¡œ
                    medicine_target_is_med1 = False
                    set_goal(*MED2_GOAL)
                    state = STATE_TO_MED2
                    rospy.loginfo("ì•½í’ˆ2 ë°°ë‹¬ ì§€ì ìœ¼ë¡œ ì´ë™ ì‹œì‘")
                else:
                    # ë°©ê¸ˆ ì•½2 ì²˜ë¦¬ â†’ ì•½1ë¡œ
                    medicine_target_is_med1 = True
                    set_goal(*MED1_GOAL)
                    state = STATE_TO_MED1
                    rospy.loginfo("ì•½í’ˆ1 ë°°ë‹¬ ì§€ì ìœ¼ë¡œ ì´ë™ ì‹œì‘")

        elif state == STATE_IDLE:
            # ëŒ€ê¸° ìƒíƒœ: í˜¸ì¶œì´ ì˜¤ë©´ 0.5ì´ˆë§ˆë‹¤ ì¢Œí‘œê°€ ì˜¨ë‹¤
            if got_udp:
                set_goal(*pixel_to_meter(u, v))
                state = STATE_TO_USER
                user_signal_sent = False
                rospy.loginfo("ì‚¬ìš©ìì—ê²Œë¡œ ì´ë™ ì‹œì‘")

        elif state == STATE_TO_USER:
            if got_udp:
                set_goal(*pixel_to_meter(u, v))
                rospy.loginfo("ì‚¬ìš©ìì—ê²Œë¡œ ì´ë™ì¤‘")
            if distance_to_goal() < GOAL_THRESH:
                state = STATE_AT_USER
                rospy.loginfo("ì‚¬ìš©ìì—ê²Œ ë„ì°©")
                # í•„ìš” ì‹œ ì‚¬ìš©ì ë„ì°© ì‹ í˜¸ 1íšŒ ì†¡ì‹ 
                if not user_signal_sent:
                    try:
                        tx_sock.sendto(b"999,999", (RPI_IP, RPI_PORT_SIGNAL))
                        rospy.loginfo("Sent UDP '999,999' to Raspberry Pi")
                        user_signal_sent = True
                    except Exception as e:
                        rospy.logwarn(f"UDP send failed: {e}")

        elif state == STATE_AT_USER:
            # ì§„ë£Œì‹¤ ì¢Œí‘œê°€ ë“¤ì–´ì˜¬ ë•Œê¹Œì§€ ëŒ€ê¸°
            if got_udp:
                set_goal(*pixel_to_meter(u, v))
                state = STATE_TO_CLINIC
                rospy.loginfo("ì§„ë£Œì‹¤ë¡œ ì´ë™ ì‹œì‘")
            else:
                rospy.loginfo("ì§„ë£Œì‹¤ ì¢Œí‘œ ëŒ€ê¸°ì¤‘")

        elif state == STATE_TO_CLINIC:
            # ìš”êµ¬ì‚¬í•­: í•­ìƒ "ì§„ë£Œì‹¤ë¡œ ì´ë™ì¤‘"ë§Œ ì¶œë ¥
            if got_udp:
                set_goal(*pixel_to_meter(u, v))   # ê³„ì† ì¶”ì¢…
            else:
                # RPiê°€ ì¢Œí‘œ ì „ì†¡ì„ ë©ˆì¶¤(= ì§„ë£Œì‹¤ ë„ì°© íŒë‹¨) â†’ ì•½í’ˆ1ë¡œ
                set_goal(*MED1_GOAL)
                state = STATE_TO_MED1
            rospy.loginfo("ì§„ë£Œì‹¤ë¡œ ì´ë™ì¤‘")

        # 3) ë„¤ë¹„ ëª©í‘œ ë°œí–‰
        goal_msg = PoseStamped()
        goal_msg.header.stamp = rospy.Time.now()
        goal_msg.header.frame_id = "map"
        goal_msg.pose.position.x = goal_x
        goal_msg.pose.position.y = goal_y
        goal_msg.pose.orientation.w = 1.0
        goal_pub.publish(goal_msg)

        # 4) RViz ì‹œê°í™”
        point_pub.publish(Point(goal_x, goal_y, 0.0))
        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = rospy.Time.now()
        marker.ns = "clicked_goal"
        marker.id = 0
        marker.type = Marker.SPHERE
        marker.action = Marker.ADD
        marker.pose.position.x = goal_x
        marker.pose.position.y = goal_y
        marker.pose.orientation.w = 1.0
        marker.scale.x = marker.scale.y = marker.scale.z = 0.15
        marker.color.r, marker.color.g, marker.color.b, marker.color.a = 0.0, 0.0, 1.0, 1.0
        marker_pub.publish(marker)

        rospy.loginfo(f"STATE({state}) GOAL({goal_x:.2f},{goal_y:.2f})")
        rate.sleep()


if __name__ == "__main__":
    try:
        udp_listener()
    except rospy.ROSInterruptException:
        pass


```

- UDP í†µì‹ ìœ¼ë¡œ ë¼ì¦ˆë² ë¦¬íŒŒì´ì™€ ë¡œë´‡ ê°„ ì¢Œí‘œÂ·ì‹ í˜¸ë¥¼ ì£¼ê³ ë°›ìœ¼ë©° ì œì–´í•œë‹¤.
- BLEÂ·IMU ë°ì´í„°ë¥¼ EKFë¡œ ìœµí•©í•´ ì‹¤ë‚´ ìœ„ì¹˜ë¥¼ ì¶”ì •í•˜ê³  ì§€ë„ì— í‘œì‹œí•œë‹¤.
- ì‚¬ìš©ìì˜ ëª©ì ì§€ ì„ íƒì— ë”°ë¼ ê²½ë¡œ íƒìƒ‰Â·ë²½ íšŒí”¼Â·ë¡œë´‡ í˜¸ì¶œ ë“± ìƒíƒœ ê¸°ë°˜ ë„¤ë¹„ê²Œì´ì…˜ì„ ìˆ˜í–‰í•œë‹¤.
```
import joblib
import sys
import serial
import time
import numpy as np
import socket
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QShortcut, QLabel, QGraphicsDropShadowEffect
from PyQt5.QtCore import QTimer, QMutex, Qt, QFile, QTextStream, QPointF, QThread, pyqtSignal
from PyQt5.QtGui import QKeySequence, QColor

# --- ëª¨ë“ˆ ì„í¬íŠ¸ ---
from app_config import load_config
from fingerprinting import FingerprintDB
from trilateration import EKF
from ble_scanner import BLEScanThread
from map_viewer import MapViewer
from serial_reader import SerialReader
from event import SelectionDialog
from bin import create_binary_map
from Astar import find_path, create_distance_map
from robot_tracker import RobotTrackerThread
from lgbm_predictor import LGBM_Classifier_Predictor

# --- UDP ìˆ˜ì‹  ìŠ¤ë ˆë“œ í´ë˜ìŠ¤ ---
class UDPReceiverThread(QThread):
    message_received = pyqtSignal(str)
    def __init__(self, port, parent=None):
        super().__init__(parent)
        self.port, self.is_running = port, True
    def run(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0', self.port)); sock.settimeout(1.0)
        print(f"UDP ìˆ˜ì‹  ëŒ€ê¸° ì‹œì‘ (í¬íŠ¸: {self.port})")
        while self.is_running:
            try:
                data, _ = sock.recvfrom(1024)
                message = data.decode().strip()
                if message: self.message_received.emit(message)
            except socket.timeout: continue
        sock.close()
    def stop(self): self.is_running = False


# --- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ í´ë˜ìŠ¤ ---
class IndoorPositioningApp(QWidget):
    def __init__(self, config):
        super().__init__()
        self.config, self.room_coords = config, {room['name']: (room['x'], room['y']) for room in config['rooms']}
        self.rssi_mutex, self.rssi_data = QMutex(), {}
        # fused_posë¥¼ íŠœí”Œì´ ì•„ë‹Œ NumPy ë°°ì—´ë¡œ ì´ˆê¸°í™”
        self.current_speed, self.current_yaw, self.fused_pos = 0.0, 180.0, np.array([0.0, 0.0])
        self.target_room, self.last_start_grid, self.BLOCK_SIZE = None, None, 10

        # ë²½ íšŒí”¼ ê¸°ëŠ¥ íŒŒë¼ë¯¸í„°
        self.AVOIDANCE_THRESHOLD_GRID = 50
        self.REPULSION_STRENGTH = 0.03

        self.robot_arrival_processed = False

        self.udp_target_ip = self.config.get('udp_target_ip', "10.24.184.20")
        self.udp_target_port = self.config.get('udp_target_port', 5005)
        self.udp_socket, self.udp_send_timer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM), QTimer(self)
        self.udp_destination_timer = QTimer(self)
        self.udp_receiver = UDPReceiverThread(port=self.config.get('udp_listen_port', 5006))

        # ë²½ íšŒí”¼ ë³´ì •ì„ ìœ„í•œ íƒ€ì´ë¨¸
        self.wall_avoidance_timer = QTimer(self)


        self._init_logic_components(); self._init_ui(); self._connect_signals(); self._start_timers()

    def _init_logic_components(self):
        binary_grid_as_list = create_binary_map(self.config['map_file'], block_size=self.BLOCK_SIZE)
        if binary_grid_as_list is not None:
            self.binary_grid = np.array(binary_grid_as_list)
            dist_map_as_list, self.max_dist = create_distance_map(self.binary_grid)
            self.distance_map = np.array(dist_map_as_list)
        else:
            self.close()
        self.ekf = EKF(self.config.get('ekf_dt', 1.0))
        try:
            self.lgbm_predictor = joblib.load('lgbm_predictor.pkl')
            print("ì €ì¥ëœ LGBM Predictor ê°ì²´ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.")
        except FileNotFoundError:
            print("ì˜¤ë¥˜: ì €ì¥ëœ Predictor íŒŒì¼(lgbm_predictor.pkl)ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            self.lgbm_predictor = None
        self.ble_scanner_thread = BLEScanThread(self.config)
        try:
            imu_port, baudrate = self.config.get('imu_port', '/dev/ttyUSB0'), self.config.get('imu_baudrate', 115200)
            self.serial_port = serial.Serial(imu_port, baudrate); time.sleep(1); self.serial_port.write(b'ZERO\n')
            self.serial_reader = SerialReader(port=imu_port, baudrate=baudrate); self.serial_reader.start()
        except serial.SerialException as e:
            print(f"ì‹œë¦¬ì–¼ í¬íŠ¸ ì˜¤ë¥˜: {e}."); self.serial_reader = None

        self.robot_tracker = RobotTrackerThread(port=self.config.get('robot_udp_port', 5005))

    def _init_ui(self):
        self.toast_label = QLabel(self); self.toast_label.setObjectName("Toast"); self.toast_label.setAlignment(Qt.AlignCenter); self.toast_label.hide()

        # ë¡œë´‡ í˜¸ì¶œ ìƒíƒœ ìœ„ì ¯
        self.setObjectName("MainWindow")
        self.robot_status_widget = QWidget(self)
        self.robot_status_widget.setObjectName("RobotStatus")
        self.robot_status_widget.hide()
        status_layout = QHBoxLayout(self.robot_status_widget)
        status_layout.setContentsMargins(25, 10, 25, 10); status_layout.setSpacing(20)
        status_layout.addWidget(QLabel("ë¡œë´‡ì´ ì˜¤ê³  ìˆìŠµë‹ˆë‹¤..."))
        self.stop_call_btn = QPushButton("ì¤‘ì§€"); self.stop_call_btn.setObjectName("StopCallButton")
        status_layout.addWidget(self.stop_call_btn)
        shadow = QGraphicsDropShadowEffect(); shadow.setBlurRadius(25); shadow.setColor(QColor(0, 0, 0, 80)); shadow.setOffset(0, 4)
        self.robot_status_widget.setGraphicsEffect(shadow)

        # ë¡œë´‡ ë„ì°© í™•ì¸ ìœ„ì ¯
        self.arrival_prompt_widget = QWidget(self)
        self.arrival_prompt_widget.setObjectName("ArrivalPrompt")
        self.arrival_prompt_widget.hide()
        arrival_layout = QVBoxLayout(self.arrival_prompt_widget)
        arrival_layout.setContentsMargins(20, 20, 20, 20); arrival_layout.setSpacing(15); arrival_layout.setAlignment(Qt.AlignCenter)
        message_layout = QHBoxLayout(); message_layout.setSpacing(15); message_layout.setAlignment(Qt.AlignCenter)
        message_label = QLabel("ë¡œë´‡ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤.<br>ì§„ë£Œì‹¤ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
        message_label.setAlignment(Qt.AlignCenter)
        message_layout.addWidget(message_label)
        self.confirm_move_btn = QPushButton("í™•ì¸"); self.confirm_move_btn.setObjectName("ConfirmMoveButton")
        arrival_layout.addLayout(message_layout)
        arrival_layout.addWidget(self.confirm_move_btn, alignment=Qt.AlignCenter)
        arrival_shadow = QGraphicsDropShadowEffect(); arrival_shadow.setBlurRadius(25); arrival_shadow.setColor(QColor(0, 0, 0, 80)); arrival_shadow.setOffset(0, 4)
        self.arrival_prompt_widget.setGraphicsEffect(arrival_shadow)

        # ê¸¸ì•ˆë‚´ ìƒíƒœ ìœ„ì ¯
        self.navigation_status_widget = QWidget(self)
        self.navigation_status_widget.setObjectName("NavigationStatus")
        self.navigation_status_widget.hide()
        nav_layout = QHBoxLayout(self.navigation_status_widget)
        nav_layout.setContentsMargins(25, 10, 25, 10); nav_layout.setSpacing(20)
        nav_layout.addWidget(QLabel("ë¡œë´‡ì„ ë”°ë¼ ì´ë™í•˜ì„¸ìš”.."))
        self.cancel_nav_btn = QPushButton("ì·¨ì†Œ"); self.cancel_nav_btn.setObjectName("CancelNavButton")
        nav_layout.addWidget(self.cancel_nav_btn)
        nav_shadow = QGraphicsDropShadowEffect(); nav_shadow.setBlurRadius(25); nav_shadow.setColor(QColor(0, 0, 0, 80)); nav_shadow.setOffset(0, 4)
        self.navigation_status_widget.setGraphicsEffect(nav_shadow)

        # í˜„ì¬ ê²½ë¡œ ì•ˆë‚´ ìœ„ì ¯ (ì¢Œì¸¡ ìƒë‹¨)
        self.current_nav_widget = QWidget(self)
        self.current_nav_widget.setObjectName("CurrentNav")
        self.current_nav_widget.hide()
        nav_info_layout = QHBoxLayout(self.current_nav_widget)
        nav_info_layout.setContentsMargins(20, 10, 20, 10); nav_info_layout.setSpacing(15)
        self.current_nav_label = QLabel("ì•ˆë‚´: ")
        self.current_nav_cancel_btn = QPushButton("ì·¨ì†Œ")
        self.current_nav_cancel_btn.setObjectName("CurrentNavCancelButton")
        nav_info_layout.addWidget(self.current_nav_label)
        nav_info_layout.addWidget(self.current_nav_cancel_btn)
        current_nav_shadow = QGraphicsDropShadowEffect(); current_nav_shadow.setBlurRadius(20); current_nav_shadow.setColor(QColor(0, 0, 0, 70)); current_nav_shadow.setOffset(0, 3)
        self.current_nav_widget.setGraphicsEffect(current_nav_shadow)

        # ë©”ì¸ ë ˆì´ì•„ì›ƒ
        self.map_viewer = MapViewer(self.config['map_file'], self.config['px_per_m_x'], self.config['px_per_m_y'])
        self.map_viewer._init_est_items(0, 0, 180.0)
        self.nav_btn = QPushButton("ê¸¸ì•ˆë‚´"); self.nav_btn.setObjectName("NAV")
        self.robot_btn = QPushButton("ë¡œë´‡\ní˜¸ì¶œ"); self.robot_btn.setObjectName("Robot")
        right_layout = QVBoxLayout(); right_layout.addWidget(self.nav_btn); right_layout.addWidget(self.robot_btn)
        main_layout = QHBoxLayout(self); main_layout.addWidget(self.map_viewer); main_layout.addLayout(right_layout)

        main_layout.setSpacing(13)

        self.setWindowTitle("ODIGA"); self.setFocusPolicy(Qt.StrongFocus); self.load_stylesheet('stylesheet.qss'); self.showFullScreen(); self.setFocus()

    def _connect_signals(self):
        self.ble_scanner_thread.detected.connect(self._on_ble_device_detected)

        if self.serial_reader:
            self.serial_reader.heading_received.connect(self._on_yaw_update)
            self.serial_reader.speed_received.connect(self._on_speed_update)
        self.nav_btn.clicked.connect(self._show_selection_dialog)
        self.robot_btn.clicked.connect(self._on_robot_call_clicked)
        self.stop_call_btn.clicked.connect(self._on_robot_call_stop_clicked)
        self.confirm_move_btn.clicked.connect(self._on_arrival_confirmed)
        self.cancel_nav_btn.clicked.connect(self._on_navigation_cancel_clicked)
        self.current_nav_cancel_btn.clicked.connect(lambda: self._stop_navigation("ì•ˆë‚´ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤."))
        shortcut = QShortcut(QKeySequence("G"), self); shortcut.activated.connect(self._start_ble_scan)
        self.udp_send_timer.timeout.connect(self._send_position_udp)
        self.udp_destination_timer.timeout.connect(self._send_destination_udp)
        self.udp_receiver.message_received.connect(self._on_robot_message_received)
        self.robot_tracker.robot_position_updated.connect(self._on_robot_position_update)

        # ë²½ íšŒí”¼ íƒ€ì´ë¨¸ì˜ timeout ì‹ í˜¸ë¥¼ _apply_wall_avoidance ë©”ì„œë“œì— ì—°ê²°
        self.wall_avoidance_timer.timeout.connect(self._apply_wall_avoidance)


    def _start_timers(self):
        self.rssi_clear_timer = QTimer(self); self.rssi_clear_timer.timeout.connect(self._clear_rssi_cache); self.rssi_clear_timer.start(2000)
        self.udp_receiver.start()
        self.robot_tracker.start()


    def _on_robot_position_update(self, px, py):
        self.map_viewer.update_robot_position(px, py)

    def _send_position_udp(self):
        px, py = self.fused_pos[0] * self.config['px_per_m_x'], self.fused_pos[1] * self.config['px_per_m_y']
        message = f"{int(px)},{int(py)}"
        self.udp_socket.sendto(message.encode(), (self.udp_target_ip, self.udp_target_port))
        print(f"UDP Sent: {message}")

    def _send_destination_udp(self):
        """ì„¤ì •ëœ ëª©ì ì§€(target_room)ì˜ ì¢Œí‘œë¥¼ UDPë¡œ ì „ì†¡í•©ë‹ˆë‹¤."""
        if self.target_room:
            dest_m = self.target_room
            dest_px = dest_m[0] * self.config['px_per_m_x']
            dest_py = dest_m[1] * self.config['px_per_m_y']
            message = f"{int(dest_px)},{int(dest_py)}"
            self.udp_socket.sendto(message.encode(), (self.udp_target_ip, self.udp_target_port))
            print(f"UDP Destination Sent: {message}")
        else:
            self.udp_destination_timer.stop()
            print("ì˜¤ë¥˜: ëª©ì ì§€ê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ëª©ì ì§€ ì „ì†¡ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.")

    def _show_toast(self, message, duration=3000):
        self.toast_label.setText(message); self.toast_label.adjustSize()
        self._update_popup_position(self.toast_label)
        self.toast_label.show(); self.toast_label.raise_()
        QTimer.singleShot(duration, self.toast_label.hide)

    def _update_popup_position(self, popup_widget):
        x = (self.width() - popup_widget.width()) / 2; y = 50
        popup_widget.move(int(x), int(y))

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._update_popup_position(self.toast_label)
        self._update_popup_position(self.robot_status_widget)
        self._update_popup_position(self.arrival_prompt_widget)
        self._update_popup_position(self.navigation_status_widget)
        self.current_nav_widget.move(20, 20)

    def _update_navigation_path(self):
        if not self.target_room: return

        user_px = self.fused_pos[0] * self.config['px_per_m_x']
        user_py = self.fused_pos[1] * self.config['px_per_m_y']
        target_px = self.target_room[0] * self.config['px_per_m_x']
        target_py = self.target_room[1] * self.config['px_per_m_y']

        distance = np.sqrt((user_px - target_px)**2 + (user_py - target_py)**2)

        if distance < 25:
            self._stop_navigation("<b>ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.</b> ì•ˆë‚´ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.")
            return

        start_m, end_m = self.fused_pos, self.target_room
        start_grid, end_grid = self.meters_to_grid(start_m), self.meters_to_grid(end_m)

        # ì‹œì‘ì ì´ ë§µ ë²”ìœ„ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ì•ˆì „ ì½”ë“œ
        grid_height, grid_width = self.binary_grid.shape
        if not (0 <= start_grid[0] < grid_height and 0 <= start_grid[1] < grid_width):
            print(f"ê²½ê³ : ì‹œì‘ì  {start_grid}ì´(ê°€) ë§µ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return # í•¨ìˆ˜ë¥¼ ì¦‰ì‹œ ì¢…ë£Œí•˜ì—¬ ì˜¤ë¥˜ ë°©ì§€

        if self.last_start_grid == start_grid: return
        self.last_start_grid = start_grid
        path_grid = find_path(self.binary_grid, start_grid, end_grid, self.distance_map, self.max_dist, self.config.get('penalty_strength', 2.5))
        path_pixels = [self.grid_to_pixels(pos) for pos in path_grid] if path_grid else None
        self.map_viewer.draw_path(path_pixels)

    def _get_direction_from_yaw(self, yaw):
        """Yaw ê°ë„ë¥¼ N, E, S, W ë°©í–¥ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤."""
        if 45 <= yaw < 135:
            return 'S'
        elif 135 <= yaw < 225:
            return 'W'
        elif 225 <= yaw < 315:
            return 'N'
        else: # 315 <= yaw or yaw < 45
            return 'E'

    def _on_ble_device_detected(self, rssi_vec):
        self.rssi_mutex.lock()
        self.rssi_data.update(rssi_vec)
        local_rssi_copy = self.rssi_data.copy()
        self.rssi_mutex.unlock()

        if len(local_rssi_copy) >= 1:
            if self.lgbm_predictor:
                try:
                    # 1. IMU ì„¼ì„œì—ì„œ ë°›ì€ Yaw ê°’ìœ¼ë¡œ í˜„ì¬ ë°©í–¥('N' ë“±)ì„ ê²°ì •í•©ë‹ˆë‹¤.
                    direction = self._get_direction_from_yaw(self.current_yaw)
                    local_rssi_copy['direction'] = direction

                    # 2. Predictor ê°ì²´ì˜ predict ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. (ë‚´ë¶€ì—ì„œ ëª¨ë“  ì „ì²˜ë¦¬ ìˆ˜í–‰)
                    predicted_label = self.lgbm_predictor.predict(local_rssi_copy)

                    # 3. ì˜ˆì¸¡ëœ ë ˆì´ë¸”('x_y')ì„ ì¢Œí‘œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
                    x_str, y_str = predicted_label.split('_')
                    pts_grid = (int(x_str)  , int(y_str) )
                    pts_pixels_qpoint = self.grid_to_pixels(pts_grid)

                    px_per_m_x = self.config.get('px_per_m_x', 1.0)
                    px_per_m_y = self.config.get('px_per_m_y', 1.0)
                    pts_meters = np.array([
                        pts_pixels_qpoint.x() * 19 / px_per_m_x,
                        pts_pixels_qpoint.y() * 19 / px_per_m_y
                    ])
                    self.ekf.update(pts_meters)

                    self.fused_pos = self.ekf.get_state()[:2].flatten()

                    self.map_viewer.mark_estimated_position(*self.fused_pos, self.current_yaw)
                    self._update_navigation_path()

                except Exception as e:
                    print(f"LGBM ì˜ˆì¸¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")


    def _on_speed_update(self, speed):
        self.current_speed = speed
        self.ekf.predict(self.current_yaw, self.current_speed)
        self.fused_pos = self.ekf.get_state()[:2].flatten()
        self._update_navigation_path()

    def _on_yaw_update(self, yaw):
        self.current_yaw = yaw
        self.map_viewer.move_to(*self.fused_pos, self.current_yaw)

    def _clear_rssi_cache(self):
        self.rssi_mutex.lock(); self.rssi_data.clear(); self.rssi_mutex.unlock()

    def _show_selection_dialog(self):
        dialog = SelectionDialog(self)
        if dialog.exec():
            selected = dialog.selected_room
            self.target_room = self.room_coords[selected]
            self._show_toast(f"<b>{selected}</b>ë¡œ ì•ˆë‚´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
            self.last_start_grid = None
            self._update_navigation_path()
            self.current_nav_label.setText(f"<b>{selected}</b> ì•ˆë‚´ì¤‘")
            self.current_nav_widget.adjustSize()
            self.current_nav_widget.show()
            self.current_nav_widget.raise_()
        else:
            self._show_toast("ì•ˆë‚´ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.", duration=2000)
            self.target_room = None
            self.map_viewer.draw_path(None)
            self.current_nav_widget.hide()

    def _start_ble_scan(self):
        if not self.ble_scanner_thread.isRunning():
            self.ble_scanner_thread.start()
            print("BLE Scan Started.")
            # BLE ìŠ¤ìº” ì‹œì‘ê³¼ í•¨ê»˜ 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ë²½ íšŒí”¼ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘
            if not self.wall_avoidance_timer.isActive():
                self.wall_avoidance_timer.start(1000) # 1000ms = 1ì´ˆ
                print("ë²½ íšŒí”¼ ë³´ì • íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤ (1ì´ˆ ê°„ê²©).")

    def _on_robot_call_clicked(self):
        if not self.target_room:
            self._show_toast("ë¡œë´‡ì„ ë¶€ë¥¼ ëª©ì ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.", duration=2500)

            dialog = SelectionDialog(self)
            if dialog.exec():
                selected = dialog.selected_room
                self.target_room = self.room_coords[selected]
                self.last_start_grid = None
                self._update_navigation_path()
                self.current_nav_label.setText(f"<b>{selected}</b> ì•ˆë‚´ì¤‘")
                self.current_nav_widget.adjustSize()
                self.current_nav_widget.show()
                self.current_nav_widget.raise_()
                self._show_toast(f"<b>{selected}</b>(ìœ¼)ë¡œ ëª©ì ì§€ ì„¤ì • í›„ ë¡œë´‡ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.")
            else:
                self._show_toast("ë¡œë´‡ í˜¸ì¶œì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.", duration=2000)
                return

        if self.udp_send_timer.isActive():
            self._show_toast("ì´ë¯¸ ë¡œë´‡ì´ í˜¸ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.")
            return

        self.robot_arrival_processed = False

        self.udp_send_timer.start(1000)
        self.robot_status_widget.adjustSize()
        self._update_popup_position(self.robot_status_widget)
        self.robot_status_widget.show()
        self.robot_status_widget.raise_()

    def _on_robot_call_stop_clicked(self):
        if self.udp_send_timer.isActive():
            self.udp_send_timer.stop()
        if self.udp_destination_timer.isActive():
            self.udp_destination_timer.stop()
        self.robot_status_widget.hide()
        self.arrival_prompt_widget.hide()
        self.navigation_status_widget.hide()
        self._show_toast("ë¡œë´‡ í˜¸ì¶œì„ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.")

    def _on_arrival_confirmed(self):
        self.arrival_prompt_widget.hide()
        self.udp_destination_timer.start(500)
        self.navigation_status_widget.adjustSize()
        self._update_popup_position(self.navigation_status_widget)
        self.navigation_status_widget.show()
        self.navigation_status_widget.raise_()

    def _stop_navigation(self, message):
        """ê¸¸ì•ˆë‚´ë¥¼ ì¤‘ì§€í•˜ê³  ê´€ë ¨ UIë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤."""
        if self.udp_destination_timer.isActive():
            self.udp_destination_timer.stop()
        self.navigation_status_widget.hide()
        self.current_nav_widget.hide()
        self.target_room = None
        self.map_viewer.draw_path(None)
        self._show_toast(message)

    def _on_navigation_cancel_clicked(self):
        self._stop_navigation("ê¸¸ì•ˆë‚´ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")

    def _on_robot_message_received(self, message):
        print(f"ë¡œë´‡ìœ¼ë¡œë¶€í„° ë©”ì‹œì§€ ìˆ˜ì‹ : '{message}'")
        if message == "1":
            self.robot_status_widget.hide()
            self.arrival_prompt_widget.hide()
            self.navigation_status_widget.hide()
            if self.udp_send_timer.isActive():
                self.udp_send_timer.stop()
            self._show_toast("ë¡œë´‡ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤.")

        elif message == "999,999":
            if not self.robot_arrival_processed:
                self.robot_arrival_processed = True
                print("ë¡œë´‡ ë„ì°© ì‹ í˜¸ (999,999) ìˆ˜ì‹ . [ìµœì´ˆ 1íšŒ ì²˜ë¦¬]")

                if self.udp_send_timer.isActive():
                    self.udp_send_timer.stop()

                self.robot_status_widget.hide()

                self.arrival_prompt_widget.adjustSize()
                self._update_popup_position(self.arrival_prompt_widget)
                self.arrival_prompt_widget.show()
                self.arrival_prompt_widget.raise_()

    def load_stylesheet(self, filename):
        qss_file = QFile(filename);
        if qss_file.open(QFile.ReadOnly | QFile.Text): self.setStyleSheet(QTextStream(qss_file).readAll())
        else: print(f"'{filename}' ìŠ¤íƒ€ì¼ì‹œíŠ¸ ë¡œë“œ ì‹¤íŒ¨!")

    def meters_to_grid(self, pos_m):
        row, col = int(pos_m[1] * self.config['px_per_m_y'] / self.BLOCK_SIZE), int(pos_m[0] * self.config['px_per_m_x'] / self.BLOCK_SIZE)
        return (row, col)

    def grid_to_pixels(self, pos_grid):
        px, py = pos_grid[1] * self.BLOCK_SIZE + self.BLOCK_SIZE / 2, pos_grid[0] * self.BLOCK_SIZE + self.BLOCK_SIZE / 2
        return QPointF(px, py)

    def _apply_wall_avoidance(self):
        """í˜„ì¬ ìœ„ì¹˜ê°€ ë²½ì— ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë³´ì •í•©ë‹ˆë‹¤. (íƒ€ì´ë¨¸ì— ì˜í•´ ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œë¨)"""
        if self.fused_pos is None or self.distance_map is None:
            return

        current_grid = self.meters_to_grid(self.fused_pos)
        row, col = current_grid

        height, width = self.distance_map.shape
        if not (0 <= row < height and 0 <= col < width):
            return

        distance_to_wall = self.distance_map[row][col]
        if distance_to_wall >= self.AVOIDANCE_THRESHOLD_GRID:
            return

        # ê±°ë¦¬ ë§µ ê·¸ë¼ë””ì–¸íŠ¸ ê·¼ì‚¬
        grad_r = self.distance_map[min(row + 1, height - 1)][col] - self.distance_map[max(row - 1, 0)][col]
        grad_c = self.distance_map[row][min(col + 1, width - 1)] - self.distance_map[row][max(col - 1, 0)]

        repulsion_vector_grid = np.array([grad_c, grad_r])
        norm = np.linalg.norm(repulsion_vector_grid)
        if norm < 1e-6:
            return

        direction_vector = repulsion_vector_grid / norm
        penetration_depth = self.AVOIDANCE_THRESHOLD_GRID - distance_to_wall
        correction_magnitude_grid = penetration_depth * self.REPULSION_STRENGTH
        correction_vector_grid = direction_vector * correction_magnitude_grid

        correction_m_x = correction_vector_grid[0] * self.BLOCK_SIZE / self.config['px_per_m_x']
        correction_m_y = correction_vector_grid[1] * self.BLOCK_SIZE / self.config['px_per_m_y']
        correction_vector_m = np.array([correction_m_x, correction_m_y])

        # fused_posì™€ EKF ìƒíƒœ ë™ì‹œì— ë³´ì •
        self.fused_pos += correction_vector_m
        try:
            
            self.ekf.x[0] = self.fused_pos[0]
            self.ekf.x[1] = self.fused_pos[1]
            
            if hasattr(self.ekf, "P"):
                self.ekf.P[:2, :2] *= 1.2
                
        except Exception as e:
            print(f"EKF ìƒíƒœ ë³´ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

        # ë³´ì •ëœ ìœ„ì¹˜ë¥¼ ì§€ë„ì— ì¦‰ì‹œ ë°˜ì˜
        self.map_viewer.mark_estimated_position(*self.fused_pos, self.current_yaw)
        print(f"ë²½ íšŒí”¼ ì ìš©: ({correction_m_x:.2f}, {correction_m_y:.2f})m ë³´ì •ë¨")

        self._update_navigation_path()

    def closeEvent(self, event):
        self.robot_tracker.stop()
        self.udp_receiver.stop()
        self.ble_scanner_thread.stop()
        if self.serial_reader: self.serial_reader.stop()

        # í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ ë²½ íšŒí”¼ íƒ€ì´ë¨¸ ì •ì§€
        if self.wall_avoidance_timer.isActive():
            self.wall_avoidance_timer.stop()

        super().closeEvent(event)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    config = load_config()
    main_window = IndoorPositioningApp(config)
    sys.exit(app.exec_())
```
